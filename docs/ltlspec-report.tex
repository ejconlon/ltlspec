\documentclass[format=acmsmall, nonacm=true, review=true]{acmart}

\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{xspace}

% Use this instead of caption to remove acmart description warnings
\newcommand{\mycaption}[1]{\Description{#1}\caption{#1}}

% Project name
\newcommand{\ltlspec}{\textit{LTLSpec}\xspace}

% This appears to fix some font problem...
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

% Junk for acmart:
\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}
\acmDOI{N/A}
\acmBooktitle{N/A}

\title{LTLSpec: An Extensible LTL Verifier for Distributed Systems}
\subtitle{CPSC 538B Final Project Report, 2021 Winter Term 1}
\author{Eric Conlon}
\author{Yanze Li}
\author{Tarcisio Teixeira}
\authorsaddresses{}
\date{2021-12-07}

\begin{document}

\begin{abstract}
  Specifying and proving properties about distributed system is hard.
  To the best of our knowledge, there isn't a canonical way of defining distributed system models for runtime verification.
  In this project, we develop \ltlspec, a runtime verification framework which allow users to take arbitrary distributed system traces and efficiently define a formal model to specify system properties in Linear Temporal Logic (LTL).
  Our framework then provide a simple LTL verifier implementation for verifying the LTL specification regarding the formal system model.
  To address the issue that LTL is only meaning on infinite traces, we introduce a simple mechanism called \textit{truncation} that allows users to define the default behaviours of quantifiers and atomic propositions after the traces end.
  To evaluate \ltlspec, we implement three actor-based distributed system examples and their corresponding specifications. The \ltlspec can successfully verify specified properties for all three examples.
\end{abstract}

\maketitle

\section{Introduction}

Proving that a distributed system operates as intended generally requires modeling the system in a formal framework equipped with its own reasoning techniques.
At one extreme of this design space, one formally specifies the program in full in exchange for strong guarantees about its behavior in all possible executions.
At another extreme, one “merely” specifies formal properties about the observable effects of the program, only able to guarantee that these properties have not been violated in observed executions.
In this project, we propose using the latter strategy, Runtime Verification, as a relatively lightweight way to explore “responsiveness properties” of actor-based distributed systems.

We define responsiveness properties following \cite{actorservice,parthasarathy2018modular} as a kind of liveness property of the form \(\Box \forall n. (P(n) \rightarrow \Diamond Q(n))\).
As an example in plain English: “When I send a certain request, I eventually get a response to that particular request.” Propositions with this structure allow one to establish domain-specific causal relations more useful than the “happens-before” of logical time.
In general, one uses a temporal logic to express these propositions. Linear Temporal Logic (LTL), with the \textit{Always} and \textit{Eventually} operators used above, is a popular choice. However, most presentations of LTL apply it to domains only with the use of atomic predicates. One cannot express dependency between these predicates as would be necessary to encode the notion of responsiveness.

As a result, some researchers have introduced first order quantifiers for data variables \cite{khoury_automata-based_2021,margaria_execution_2016,halle_runtime_2012} in systems such as LTL-FO+.
However, in an effort to increase the usefulness and applicability of the logic, we follow a slightly different path through the design space to leave the domain of quantification abstract and not internalize equality on quantified variables.

We have built a runtime verification framework with data variable quantification, decoupled from any particular domain one would verify.
In this paper, we:
\begin{itemize}
  \item Define the \textit{theory} of a distributed system, based on the concept of a first-order logical \textit{theory} of a domain
  \item Define \textit{bridge} interfaces related to each theory that allow the verifier to quantify over data variables and verify inhabitance of atomic propositions from the domain
  \item Implement an LTL \textit{verifiers} to check axioms from the theory against monitored programs and traces
  \item Introduce the \textit{truncation} mechanism to make verification perform better and yield more meaningful results against finite traces.
  \item Evaluate the effectiveness of \ltlspec on both three distributed system examples.
\end{itemize}

\section{Background}

\subsection{LTL and LTL-FO+}

\section{LTLSpec}

\begin{figure}[h]
  \includegraphics[width=0.6\textwidth]{ltlspec-overview.pdf}
  \centering
  \caption{Overview of LTLSpec}
  \label{fig:overview}
\end{figure}

\ltlspec is a verification framework aiming at providing a canonical way for specifying arbitrary LTL properties in distributed system.
Figure~\ref{fig:overview} shows the overview of the framework.
At a high level, \ltlspec consists of three components.
The \textit{theory} is a user-defined domain for verification that includes the definitions of \textit{value types}, \textit{atomic propositions}, and \textit{axioms} about the system.
The \textit{bridge} defines how to evaluate quantifiers over value types and atomic propositions in the axioms.
The LTL verifier is an interpreter over the LTL abstract syntax tree.
The details about the components will be further explained in the following subsections, along with our extension to the bridge, namely \textit{truncation}.

The verification is performed over a trace, where each element inside is called a \textit{world}.
Each axiom is verified against a world. The LTL verifier is in charge of interpreting the LTL connectives.
Once the verifier hits a quantifier or atomic proposition, it passes the current world and the corresponding quantifier or proposition to the bridge for evaluation.
This interaction ends until the axiom can no longer be evaluated.
Since proposition written in LTL talks about system properties spanning multiple worlds, the residual of the current evaluation will be carried along for further evaluation in the next world.


\subsection{First-order theories}

First, we will loosely define a language for expressing the \textit{theory} of a user’s domain. DFOL (First Order Logic with Dependent types) as encoded in LF syntax \cite{hutchison_first-order_2006} is an excellent fit for this task. It allows one to define the types of values in a domain, as well as atomic propositions over those values. (This is called a \textit{signature}.) Additionally, it allows one to express propositions with quantifiers or \textit{axioms}. Together, the signature and axioms form a theory of the domain.

\begin{figure}[h]
  {
    \fontsize{10}{12}\selectfont
    \input{../gendocs/tex/ping.tex}
  }
  \mycaption{Theory for a trivial ping system}
  \label{fig:ping-theory}
\end{figure}

\subsection{Bridge}

The theory provides a set of interfaces restricting what types, propositions, and invariants we can talk about regarding a specific distributed system trace, yet it does not provide an interpretation about for propositions and quantifiers over types.
The bridge is the component answering those questions.

\begin{figure}[h]
  {
    \fontsize{10}{12}\selectfont
    \begin{minted}{haskell}
class Eq v => Bridge e v w | w -> e v where
  -- Evaluate the atomic proposition or fail.
  bridgeEvalProp :: w -> Atom v -> Either e Prop
  -- Quantify over all values of the given type or fail.
  bridgeQuantify :: w -> TyName -> Either e [v]
\end{minted}
  }
  \mycaption{Haskell definition of a bridge}
  \label{fig:bridge-sig}
\end{figure}

Figure~\ref{fig:bridge-sig} presents the typeclass definition for bridges.
Two functions \texttt{bridgeEvalProp} and \texttt{bridgeQuantify} needs to be implemented.
\texttt{bridgeEvalProp} decides how to evaluate an atomic proposition when given correct inputs. It takes the current world \texttt{w} and the atomic proposition \texttt{Atom v} of interest as arguments. It either returns an error message \texttt{e}, if the proposition could not be successfully evaluated, or a resulting proposition \texttt{Prop} if the evaluation succeeded.
For most bridge definitions, the value of \texttt{Prop} here should be either one of the constants between \texttt{PropTrue} and \texttt{PropFalse}.

\texttt{bridgeQuantify} decides how to quantify over a specific type name regarding the current world. Similarly, it takes the current world \texttt{w} and a type name as arguments, and produce either an error \texttt{e} or a list of values \texttt{v} of the given type for quantification results.

In our current implementation, there isn't a mechanism to guarantee the correspondence between the theory and the bridge, and it is users' duty to make sure all types and propositions are correctly quantified or evaluated.
It is possible to provide users with a surface language where the compiler guarantees all bridge definitions respects the theory of the distributed system. We consider this as a future work.

\subsection{Verifier}

The verifier is an interpreter over the abstract syntax tree of an LTL proposition. Figure~\ref{fig:verifier-sig} gives the the data type definition of \texttt{EnvProp} and the signature of main evaluation function \texttt{envPropEval}.

\begin{figure}[h]
  {
    \fontsize{10}{12}\selectfont
    \begin{minted}{haskell}
-- EnvProp is an LTL proposition with its environment
-- The environment carries the data variable v
-- introduced by quantifiers in the parent propositions.
data EnvProp v =
  EnvProp !(Env v) !Prop

envPropEval :: Bridge e v w => EnvProp v -> w -> EnvPropRes e v
\end{minted}
  }
  \mycaption{Haskell definition of the verifier}
  \label{fig:verifier-sig}
\end{figure}

\subsection{Truncation}

\begin{figure}[h]
  {
    \fontsize{10}{12}\selectfont
    \begin{minted}{haskell}
-- A 'Bridge' that supports proposition truncation.
class Bridge e v w => TruncBridge e v w where
  -- The set of types with empty quantification in *all reachable worlds*
  truncBridgeEmpty :: w -> Set TyName
  -- An oracle for atomic propositions in *all reachable worlds*
  truncBridgeOracle :: w -> Atom v -> Either e TriBool
\end{minted}
  }
  \mycaption{Haskell definition of the truncation}
  \label{fig:truncation-sig}
\end{figure}

\section{Evaluation}

TODO.

\section{Related Work}

Previous work has developed logical frameworks extending separation logic to specify the responsiveness properties in actor-based systems and do proofs in Hoare-Logic style \cite{actorservice, parthasarathy2018modular}.
However, these logical frameworks have yet proven to be practical nor integrated into some existing program verification tools.
On the other hand, there are only limited existing works adopting RV for actor-based systems.
Some existing works \cite{shafiei2020actor,lavery2017actor} use the actor model to implement RV tools.
The most relevant works we can find are \cite{cassar2015synchronous,cassar2015runtime}.
\cite{cassar2015synchronous} studied the overhead between synchronous and asynchronous monitor instrumentation for actor-based systems and proposed a hybrid instrumentation technique that can be  integrated with RV tools to provide timely detection with low runtime overhead.
\cite{cassar2015runtime} proposed a runtime adaptation technique based on an existing RV tool to dynamically react to violations detected in actor-based systems.
In our project, instead of focusing on the RV techniques specifically for actor-based systems, we emphasize on how to provide an abstraction layer between the distributed application and the LTL verifiers. We want to provide an expressive specification language to help users model their application domains and specify the system's properties at the same time. This specification later acts as the contract between the real system and the verifier. We pick the actor-based system because it's a popular programming model and a clean abstraction for distributed systems.
Previous work has also shown that interesting properties about actor-based systems can be specified using an LTL-like logic[1,5].

\section{Conclusion}

TODO.

\bibliographystyle{ACM-Reference-Format}
\bibliography{ltlspec-report}

\end{document}
